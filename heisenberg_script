## Andres Pinar Sole, Center For Quantum Nanoscience, 2024

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Define parameters
spin1 = 1
spin2 = 1
D1 = 1   # in meV
D2 = 2   # in meV
B = 0    # in Tesla

def heisenberg(J, spin1, spin2, D1, D2, B):
    """
    Calculate the spin Hamiltonian using the Heisenberg model. This script can handle S=1/2,1,3/2 and 2 spin systems,
    with out of plane anisotropy D and magnetic field in the z direction B. For more advanced calculations fo two spin systems, check
    https://github.com/ManishMitharwall/Nickelocene_Spin_Sensor 
    
    Parameters:
    - J: Coupling constant
    - spin1: Spin of the first particle
    - spin2: Spin of the second particle
    - D1: Anisotropy parameter for the first particle (in meV)
    - D2: Anisotropy parameter for the second particle (in meV)
    - B: Magnetic field (in Tesla)
    
    Returns:
    - E: Eigenvalues of the Hamiltonian
    - ket: Eigenvectors of the Hamiltonian
    - E_diag: Diagonal form of the energy matrix
    - base_tot: Base labels for the combined system
    """
    
    h = 1

    # Define matrices for different spin values
    def set_spin_matrices(spin):
        if spin == 0.5:
            x1, y1, z1 = x_1_2, y_1_2, z_1_2
        elif spin == 1:
            x1, y1, z1 = x_1, y_1, z_1
        elif spin == 1.5:
            x1, y1, z1 = x_3_2, y_3_2, z_3_2
        elif spin == 2:
            x1, y1, z1 = x_2, y_2, z_2
        else:
            raise ValueError("Invalid spin value.")
        return x1, y1, z1

    def base(spin):
        if spin == 0.5:
            return base1_2
        elif spin == 1:
            return base_1
        elif spin == 1.5:
            return base3_2
        elif spin == 2:
            return base_2

    # Spin matrices and bases for different spin values
    x_1_2 = np.array([[0, 1], [1, 0]])  # Pauli X for spin 1/2
    y_1_2 = np.array([[0, -1j], [1j, 0]])  # Pauli Y for spin 1/2
    z_1_2 = np.array([[1, 0], [0, -1]])  # Pauli Z for spin 1/2
    base1_2 = [['1/2 '], ['-1/2 ']]
    
    sqrt2_inv = 1 / np.sqrt(2)  # 1/sqrt(2)
    x_1 = sqrt2_inv * np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])  # Pauli X for spin 1
    y_1 = sqrt2_inv * np.array([[0, -1j, 0], [1j, 0, -1j], [0, 1j, 0]])  # Pauli Y for spin 1
    z_1 = np.array([[1, 0, 0], [0, 0, 0], [0, 0, -1]])  # Pauli Z for spin 1
    base_1 = [['1 '], ['0 '], ['-1 ']]
    
    sqrt3_inv = 1 / np.sqrt(3)  # 1/sqrt(3)
    x_3_2 = sqrt3_inv * np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]])
    y_3_2 = sqrt3_inv * np.array([[0, -1j, 0, 0], [1j, 0, -1j, 0], [0, 1j, 0, -1j], [0, 0, 1j, 0]])
    z_3_2 = np.array([[3/2, 0, 0, 0], [0, 1/2, 0, 0], [0, 0, -1/2, 0], [0, 0, 0, -3/2]])
    base3_2 = [['3/2 '], ['1/2 '], ['-1/2 '], ['-3/2 ']]
    
    sqrt6_inv = 1 / np.sqrt(6)  # 1/sqrt(6)
    x_2 = sqrt6_inv * np.array([[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0]])
    y_2 = sqrt6_inv * np.array([[0, -1j, 0, 0, 0], [1j, 0, -1j, 0, 0], [0, 1j, 0, -1j, 0], [0, 0, 1j, 0, -1j], [0, 0, 0, 1j, 0]])
    z_2 = np.array([[2, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, -1, 0], [0, 0, 0, 0, -2]])
    base_2 = [['2 '], ['1 '], ['0 '], ['-1 '], ['-2 ']]
    
    # Define the spin matrices for the system
    base1 = np.array(base(spin1))
    base2 = np.array(base(spin2))
    x1, y1, z1 = set_spin_matrices(spin1)
    x2, y2, z2 = set_spin_matrices(spin2)
    
    # Define spin operators and Hamiltonian
    S1 = [h / 2 * np.kron(x1, np.eye(x2.shape[1])), h / 2 * np.kron(y1, np.eye(x2.shape[1])), h / 2 * np.kron(z1, np.eye(x2.shape[1]))]
    S2 = [h / 2 * np.kron(np.eye(x1.shape[1]), x2), h / 2 * np.kron(np.eye(x1.shape[1]), y2), h / 2 * np.kron(np.eye(x1.shape[1]), z2)]

    Sz_1 = np.dot(np.kron(z1, np.eye(x2.shape[1])), np.kron(np.eye(x2.shape[1]), z1))
    Sx_1 = np.dot(np.kron(x1, np.eye(x2.shape[1])), np.kron(np.eye(x2.shape[1]), x1))
    Sy_1 = np.dot(np.kron(y1, np.eye(x2.shape[1])), np.kron(np.eye(x2.shape[1]), y1))

    Sz_2 = np.dot(np.kron(z2, np.eye(x1.shape[1])), np.kron(np.eye(x1.shape[1]), z2))
    Sx_2 = np.dot(np.kron(x2, np.eye(x1.shape[1])), np.kron(np.eye(x1.shape[1]), x2))
    Sy_2 = np.dot(np.kron(y2, np.eye(x1.shape[1])), np.kron(np.eye(x1.shape[1]), y2))
    
    # Sz spin operators
    B = 0.01 * B
    Bsz1 = np.kron(z1, np.eye(x2.shape[1]))  #
    Bsz2 = np.kron(z2, np.eye(x1.shape[1]))

    # Calculate Hamiltonian
    H = J * (np.dot(S1[0], S2[0]) + np.dot(S1[1], S2[1]) + np.dot(S1[2], S2[2])) + Sz_1 * D1 + Sz_2 * D2 + B * (Bsz1 + Bsz2)

    # Compute eigenvalues and eigenvectors
    E, ket = np.linalg.eigh(H)

    # Round and extract the real part of eigenvalues and eigenvectors
    E = np.round(E, 2).real
    ket = np.round(ket, 2).real
    E_diag = np.diag(np.round(E, 1).real)

    def kronecker_product_str(A, B):
        """
        Calculate the Kronecker product of matrices A and B with string elements.
        """
        rows_A, cols_A = A.shape
        rows_B, cols_B = B.shape
        result = []
        for i in range(rows_A):
            for j in range(cols_A):
                block = [[A[i, j] + B[m, n] for n in range(cols_B)] for m in range(rows_B)]
                result.extend(block)
        return np.array(result)

    base_tot = kronecker_product_str(base1, base2)
    
    return E, ket, E_diag, base_tot

# Run the Heisenberg model calculation
result = heisenberg(2, spin1=spin1, spin2=spin2, D1=D1, D2=D2, B=B)
E, ket, E_diag, base_tot = result

# Define the range of J values
JJ = np.linspace(0, 2, 150)
eigenvalues = np.array([heisenberg(j, spin1=spin1, spin2=spin2, D1=D1, D2=D2, B=B)[0] for j in JJ])

# Create DataFrame with named rows and columns for ket matrix
ket_matrix = pd.DataFrame(ket, columns=base_tot, index=base_tot)

# Map base labels to state names (customize this mapping as needed)
base_to_state = {tuple(base): f'State {i}' for i, base in enumerate(base_tot)}

# Extract non-zero entries and their corresponding base labels
results = {}
for col in ket_matrix.columns:
    non_zero_entries = ket_matrix[col][ket_matrix[col] != 0]
    associated_base = [base for base in ket_matrix.index[ket_matrix[col] != 0]]
    results[col] = list(zip(associated_base, non_zero_entries))

# Define labels for eigenvectors
fila = ['ψ' + str(x) for x in range(len(E))]

# Plot the eigenvalues as a function of J
plt.figure(figsize=(10, 6))
for i in range(eigenvalues.shape[1]):
    plt.plot(JJ, eigenvalues[:, i] - eigenvalues[:, 0], '--', label=f'E-E0 {i}')
plt.xlabel('J (meV)')
plt.ylabel('E-E0 (meV)')
plt.title('Energy as a Function of J')
plt.legend(fila, loc='upper left', bbox_to_anchor=(1, 1))
plt.grid(True)
plt.show()

# Display the ket matrix with eigenvector labels
ket_matrix = pd.DataFrame(ket, columns=fila, index=base_tot)
ket_matrix.style.set_caption("Eigenvectors")
display(ket_matrix.style.set_caption("Eigenvectors"))
# each state ψ is a linear combination of the eigenvectors on its column
